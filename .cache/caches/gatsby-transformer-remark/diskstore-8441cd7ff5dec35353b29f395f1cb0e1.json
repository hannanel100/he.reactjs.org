{"expireTime":9007200917365142000,"key":"transformer-remark-markdown-html-d400b63a0bb412489b1358338ae941df-gatsby-remark-responsive-iframegatsby-remark-imagesgatsby-remark-external-linksgatsby-remark-header-custom-idsgatsby-remark-code-replsgatsby-remark-embed-snippetgatsby-remark-use-jsxgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<p>React, לפי דעתנו, היא ספריית הג’וואה-סקריפט המובילה בבניית יישומי אינטרנט. הספרייה הוכיחה את עצמה אצלנו בפייסבוק ובאינסטגרם.</p>\n<p>אחד מהיתרונות הבולטים של React  הוא איך הוא גורם לך לחשוב על היישומים בזמן שאתה בונה אותם. במדריך זה, נלווה אותך בתהליך החשיבה של בניית טבלת נותני מוצרים באמצעות React.</p>\n<h2 id=\"start-with-a-mock\"><a href=\"#start-with-a-mock\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>נתחיל עם דוגמא</h2>\n<p>נניח שיש לנו ממשק JSON שנראה ככה:</p>\n<p>\n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 228px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 121.42857142857144%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAIAAAB1KUohAAAACXBIWXMAABYlAAAWJQFJUiTwAAACm0lEQVQ4y4WUi26iQBSG+/5Ps5v0Qo20VWtRuTgCsYARDcIwqCPDTRCQ2Shd12zV/iGEDHzzn3M4Z+6qqiqKIv+r3RXleU6/6a4oCoxxcBQhJI7j3W6XnSlN0yzL4jje7/fVmb5gCKFt26vVCmMcRRG9pDRN9/v9/85lWaZpijF2HIcQ4vs+Qmiz2QRBsF6v6x3XR8VxHIZhHWBRFF8wIWQ+n/d6PQCAruscxwmCcHro9/s8zwMAZrMZAKDb7fZ6vSAIDvB5GHUmF3Xx1QHmOK62dRyn/shxnNfXV1VVLcuqyfM6nTY6wOPxuN/va5rmOE69SggZj8eTyeQEXwznAIuiqGmaYRjD4VBRFFVVBUGAEMqyDCH8AQYAcBynaZppmu/v75qmybL8+fkpSdLPzoZhmKYJAFAUpY4cISRJkq7rPM9Pp9NbBQuCwHXdhWWZpkkIqXNeLBae50EIfd+/BYuiOJQkGQB5NBqKIq0q27Y/Pj5GR9HrOsCu6849b7FcLjwPYkwpDYPAsiyE0HK5vPHzj03SaFCGOdyfnqqHB8qy1nTa6nQURel2u4Zh3Aq7hLCaz6ltU9uuZjOKULrdIoR831+v10mS3HL+dX//m2Ganc59o9HsdJiXl8FgcLtb/8F4tcKrFfH9pefFURQGAcZ4u93meZ5lWT1A1zsMgOGxKzRdH45GsqIAAJ6fnwVBaLfbk8nkas4VpbnrRgglSZJn2cZx4uPQuhDWg40x/n4MnFWbZQ/X4yN9e6sGA1oUluO0222WZRVFYVm2nt7v5ne0qqIoSrfbIoqyKErCkFIaJwnGeLPZhGGIMS7L8qozz/OtVosXRVlVXYQopaZpSpLUbDYlSWIY5rrzcbUsyyLPTw6n0a9PzGvV/gPqU0Td/eZ9wAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Mockup\"\n        title=\"\"\n        src=\"/static/1071fbcc9eed01fddc115b41e193ec11/d4770/thinking-in-react-mock.png\"\n        srcset=\"/static/1071fbcc9eed01fddc115b41e193ec11/65ed1/thinking-in-react-mock.png 210w,\n/static/1071fbcc9eed01fddc115b41e193ec11/d4770/thinking-in-react-mock.png 228w\"\n        sizes=\"(max-width: 228px) 100vw, 228px\"\n      />\n    </span>\n  </span>\n  </p>\n<p>הממשק מחזיר מידע בפורמט JSON שנראה ככה:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"gatsby-code-text\"><code class=\"gatsby-code-text\">[\n  {category: \"Sporting Goods\", price: \"$49.99\", stocked: true, name: \"Football\"},\n  {category: \"Sporting Goods\", price: \"$9.99\", stocked: true, name: \"Baseball\"},\n  {category: \"Sporting Goods\", price: \"$29.99\", stocked: false, name: \"Basketball\"},\n  {category: \"Electronics\", price: \"$99.99\", stocked: true, name: \"iPod Touch\"},\n  {category: \"Electronics\", price: \"$399.99\", stocked: false, name: \"iPhone 5\"},\n  {category: \"Electronics\", price: \"$199.99\", stocked: true, name: \"Nexus 7\"}\n];</code></pre></div>\n<h2 id=\"step-1-break-the-ui-into-a-component-hierarchy\"><a href=\"#step-1-break-the-ui-into-a-component-hierarchy\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>השלב הראשון: פיצול ממשק המשתמש להיררכיית קומפוננטות </h2>\n<p>הדבר הראשון שנעשה הוא להקיף כל קומפוננטה(ותת קומפוננטה) בקופסה, ולתת לכל אחת שם. אם אתם עובדים עם מעצב/ת , יכול להיות שהוא/היא כבר עשו את זה.</p>\n<p>אבל איך יודעים מה צריך להיות קומפוננטה משלו? משתמשים באותה טכניקה שבה מחליטים אם ליצור מתודה או עצם.\nאחת השיטות היא <a href=\"https://en.wikipedia.org/wiki/Single_responsibility_principle\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">עיקרון האחריות הבודדת</a>, שאומר, שאופן אידיאלי כל קומפוננטה אמורה לעשות דבר אחד בלבד. אם הקומפוננטה גדלה, נצטרך לפצל אותה לתת-קומפוננטות.</p>\n<p>משום שלעיתים תכופות נצטרך להציג מידע בפורמט JSON למשתמש, נראה שאם המודל נבנה כראוי, ממשק המשתמש שלנו( וגם מבנה הקומפוננטות ) ימופה באופן מסודר. זה קורה מכיוון שממשק המשתמש ומודלי המידע נוטים לדבוק באותה <em>ארכיטקטורת מידע</em>. פצל את ממשק המשתמש שלך לקומפוננטות, שכל אחת מהן מתאימה לחלק אחד של מודל המידע שלך.</p>\n<p>\n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 605px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 64.76190476190476%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAACHUlEQVQoz12S63KbMBCFef9nSpPUSWp8qy/cUjvGwiBDEBICSdyEpI7bJk1yZmf/7H6zO2fXMh+ktRJcCDEI0TPeMvYvOO847xjvGy5GOQyDJIQ0TWN9hJXSFetyhDGhbTcMUslRX7Mcr1VtsldSV2VRFBBChNAneBwV5wPBZRhGEYizNI/PEJzi1wxFIEaoYqwzZqRVdTgc6rq2vqyNReUBsE+SV8ac4zGIooSQC6WwLPcQhmfQCn5J0yiK2ra19JuusBlhk92tV3bgHlA6++XtopAbQ7XixhRKguwoGCOEnM/nvu8t9UfGmKEfCMXPobNerOazqec4m/V6tVyiAnHGqrJM0oSPlVYKQggAuBpWFAXGmBBCy7KVLWcXMJv7k+80PKbr1Xk2VTAxeTYmyWn6AOBeMG6MkVIqpaw4jiGEeZ5XlDayo8Wpm9w3dzf99PG4XLhPj+ICdUn6PAfrZXDYPgeBPZuFYZjnuXW9mpRa674faF0Gkf/Ttndze7dcRBASVpec1U3DRJNQjBuUQvjt9tZ13TiOrTef/xqmSpY6250TeNvtxttuDr5XFqhlrKnr6PTi7je+53HOtdZSys93NkqQs3l61D8m0ndP85l3e4MD3+BivMCT/fQSBWoc34d9hSsaJ/YULqYCHOFu4z3cZ75jMGrjCGwWbKTv5Ff4+tsDok1OW8QHzDpUNTnrkBgw7zEfin6sjP7f/xuv0NKDlOs/JwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"תרשים המראה nesting של קומפוננטות\"\n        title=\"\"\n        src=\"/static/9381f09e609723a8bb6e4ba1a7713b46/90cbd/thinking-in-react-components.png\"\n        srcset=\"/static/9381f09e609723a8bb6e4ba1a7713b46/65ed1/thinking-in-react-components.png 210w,\n/static/9381f09e609723a8bb6e4ba1a7713b46/d10fb/thinking-in-react-components.png 420w,\n/static/9381f09e609723a8bb6e4ba1a7713b46/90cbd/thinking-in-react-components.png 605w\"\n        sizes=\"(max-width: 605px) 100vw, 605px\"\n      />\n    </span>\n  </span>\n  </p>\n<p>נראה כאן שיש לנו חמש קומפוננטות ביישום שלנו. המידע שכל קומפוננטה מייצגת הוא בפונט italic</p>\n<ol>\n<li><strong><code class=\"gatsby-code-text\">FilterableProductTable</code> (כתום):</strong> מכיל את כל תכולת הדוגמה</li>\n<li><strong><code class=\"gatsby-code-text\">SearchBar</code> (כחול):</strong> <em>קלט המשתמש</em></li>\n<li><strong><code class=\"gatsby-code-text\">ProductTable</code> (ירוק):</strong> מציג ומסנן את <em>המידע</em> על סמך <em>קלט המשתמש</em></li>\n<li><strong><code class=\"gatsby-code-text\">ProductCategoryRow</code> (טורקיז):</strong> מציג כותרת לכל <em>קטגוריה</em></li>\n<li><strong><code class=\"gatsby-code-text\">ProductRow</code> (אדום):</strong> מציג שורה לכל <em>מוצר</em></li>\n</ol>\n<p>אם נסתכל על ProductTable, נראה שכותרת הטבלה( שמכילה את כותרות השם והמחיר ) היא לא קומפוננטה משלה. אפשר להפוך אותה לקומפוננטה משלה ואפשר גם שלא, זה עניין של בחירה.\nבדוגמה זאת, השארנו אותו חלק מProductTable  בגלל שזה חלק מרינדור <em>המידע</em>, שהוא עבודת הקומפוננטה ProductTable.\nלעומת זאת, אם הכותרת גדלה ונהיית מסובכת( לדוגמה אם היינו מוסיפים חיפוש ), זה בהחלט יעלה צורך לפצל אותה לקומפוננטה משלה( ProductTableHeader ).\nעכשיו לאחר שזיהינו את הקומפוננטות בדוגמה שלנו, נסדר אותם בהיררכיה. קומפוננטות שנמצאות בתוך קומפוננטות אחרות צריכות להופיע מתחתיהן בהיררכיה:</p>\n<h2 id=\"step-2-build-a-static-version-in-react\"><a href=\"#step-2-build-a-static-version-in-react\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step 2: בניית גרסה סטטית בReact </h2>\n<p data-height=\"600\" data-theme-id=\"0\" data-slug-hash=\"BwWzwm\" data-default-tab=\"js\" data-user=\"lacker\" data-embed-version=\"2\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/gaearon/pen/BwWzwm\">Thinking In React: Step 2</a> on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n<p>עכשיו שיש לנו את היררכיית הקומפוננטות שלנו, זה הזמן ליישם את היישום. הדרך הקלה ביותר היא לבנות גרסה שלוקחת את מודל המידע ומרנדרת את ממשק המשתמש, אבל אין לה אינטראקטיביות. מומלץ לפצל תהליכים אלו בגלל שבניית גרסה סטטית דורשת הרבה הקלדה ומינימום חשיבה, והוספת אינטראקטיביות דורשת הרבה חשיבה ומינימום הקלדה. נראה למה.</p>\n<p>על מנת לבנות גרסה סטטית של היישום שמרנדרת את מודל המידע, נרצה לבנות קומפוננטות שמשתמשות בקומפוננטות אחרות ומעבירות מידע באמצעות props<strong>.<em>props</em> הם דרך העברת מידע מ’הורה’ ל’ילד’. אם אתם מכירים את הקונספט של  <em>state</em>, **אל תשתמשו בstate  בכלל</strong> על מנת לבנות את הגרסה הסטטית. state  שמור רק לאינטראקטיביות, שזה מידע שמשתנה לאורך זמן. מכיוון שזאתי גרסה סטטית של היישום, לא נצטרך state.</p>\n<p>נוכל לבנות מלמעלה למטה או מלמטה למעלה. שזה אומר שנוכל להתחיל לבנות את הקומפוננטות מלמעלה בהירככיה( נתחיל מFilterableProductTable ) או מהקומפוננטות התחתונות בהיררכיה( ProductRow  ). בדוגמות פשוטות יותר, זה קל יותר להתחיל מלמעלה למטה, ובפרויקטים גדולים, זה קל יותר להתחיל מלמטה למעלה ולכתוב tests במקביל לבנייה.</p>\n<p>&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C; HEAD\nבסוף השלב הזה, יהיה לנו ספרייה של קומפוננטות שמישות שמרנדרות את מודל המידע. הקומפוננטות יכילו רק מתודות render()  מכיון שזוהי גרסה סטטית של היישום. הקומפוננטה בראש ההיררכיה(FilterableProductTable) תיקח  את מודל המידע כprop  שיועבר לה. אם נבצע שינוי למודל המידע ונקרא ל ReactDOM.render() שוב, ממשק המשתמש יעודכן. זה פשוט לראות איך ממשק המשתמש מעודכן והיכן לבצע שינויים מכיוון ששום דבר מסובך לא מתבצע. <strong>העברת המידע בכיוון אחד</strong> של React משאירה הכל בצורה מודולרית ומהירה.\n=======\nAt the end of this step, you’ll have a library of reusable components that render your data model. The components will only have <code class=\"gatsby-code-text\">render()</code> methods since this is a static version of your app. The component at the top of the hierarchy (<code class=\"gatsby-code-text\">FilterableProductTable</code>) will take your data model as a prop. If you make a change to your underlying data model and call <code class=\"gatsby-code-text\">root.render()</code> again, the UI will be updated. You can see how your UI is updated and where to make changes. React’s <strong>one-way data flow</strong> (also called <em>one-way binding</em>) keeps everything modular and fast.</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>84ad3308338e2bb819f4f24fa8e9dfeeffaa970b</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>קרא עוד ב<a href=\"/docs/getting-started.html\">תיעוד של ריאקט</a> אם תצטרך עזרה בביצוע שלב זה.</p>\n<h3 id=\"a-brief-interlude-props-vs-state\"><a href=\"#a-brief-interlude-props-vs-state\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>הפוגה קצרה:  props ו- state </h3>\n<p>יש שני סוגים של ‘מודלי’ מידע בReact : props וstate. זה חשוב להבין את ההבדלים בין השניים. קרא עוד  <a href=\"/docs/state-and-lifecycle.html\">בתיעוד של ריאקט</a> אם אתה לא בטוח מה ההבדל. ראה גם <a href=\"/docs/faq-state.html#what-is-the-difference-between-state-and-props\">שאלות נפוצות: מה ההבדל בין state ו-props?</a></p>\n<h2 id=\"step-3-identify-the-minimal-but-complete-representation-of-ui-state\"><a href=\"#step-3-identify-the-minimal-but-complete-representation-of-ui-state\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>שלב שלישי: זיהוי הייצוג המינימלי( אך מלא ) של הstate  של ממשק המשתמש </h2>\n<p>על מנת שממשק המשתמש יהיה אינטראקטיבי, נצטרך שיהיה לנו את היכולת לשנות את מודל המידע שלנו. React עושה זאת עם <strong>state</strong>.</p>\n<p>כדי לבנות את היישום בצורה נכונה, צריך לחשוב תחילה על הכמות המינימלית של state שהיישום דורש. המפתח פה הוא <a href=\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DRY: <em>Don’t Repeat Yourself</em></a> שאומר ‘אל תמחזר קוד’. נחשוב על הכמות המינימלית ביותר של state שהיישום צריך ונחשב כל דבר אחר שהיישום צריך לפי דרישה. לדוגמה, אם אנו בונים יישום של רשימת מטלות, יהיה לנו מערך של מטלות; לא נשאיר משתנה בstate בשביל הכמות מטלות. במקום זה, כשנרצה לרנדר את מספר המטלות, פשוט ניקח את אורך המערך ונציג אותו.</p>\n<p>נראה את פיסות המידע ביישום שלנו, יש לנו את:</p>\n<ul>\n<li>הרשימה המקורית של המוצרים</li>\n<li>מילות החיפוש שהמשתמש הקליד</li>\n<li>ערך תיבת הסימון</li>\n<li>הרשימה המסוננת של המוצרים</li>\n</ul>\n<p>נעבור על כל אחד ונחשוב איזה פיסת מידע היא הstate. נעשה זאת באמצעות שאילת 3 שאלות על כל פיסת מידע:</p>\n<ol>\n<li>האם המידע עובר מהורה באמצעות props? אם כן, זה לא state.</li>\n<li>האם זה נשאר קבוע לאורך זמן? אם כן, זה לא state.</li>\n<li>האם אפשר לחשב את זה לפי state אחר או props בקומפוננטה שלנו? אם כן, זה לא state.</li>\n</ol>\n<p>הרשימה המקורית עוברת באמצעות props, אז היא לא הstate. טקסט החיפוש ותיבת הסימון נראים כמתאימים להיות state מכיוון שהם משתנים לאורך זמן ולא מושפעים ממשהו. ולבסוף, הרשימה המסוננת של המוצרים היא לא הstate  מכיוון שהיא מושפעת מהרשימה המקורית של המוצרים, טקסט החיפוש וערך תיבת הסימון( מסומן או לא).</p>\n<p>אז הגענו למסקנה שהstate  שלנו הוא:</p>\n<ul>\n<li>טקסט החיפוש שהמשתמש הקליד</li>\n<li>ערך תיבת הסימון</li>\n</ul>\n<h2 id=\"step-4-identify-where-your-state-should-live\"><a href=\"#step-4-identify-where-your-state-should-live\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>שלב רביעי: זיהוי המיקום המתאים לstate </h2>\n<p data-height=\"600\" data-theme-id=\"0\" data-slug-hash=\"qPrNQZ\" data-default-tab=\"js\" data-user=\"lacker\" data-embed-version=\"2\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/gaearon/pen/qPrNQZ\">Thinking In React: Step 4</a> on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<p>זיהינו מה המרכיבים המינימליים של הstate של היישום שלנו. עכשיו אנחנו צריכים לזהות איזה קומפוננטה משנה, או לוקחת <em>בעלות</em> על הstate.</p>\n<p>זכרו:  בReact הכל סובב סביב העברת מידע למטה בהיררכיית הקומפוננטות. זה לפעמים לא ברור מיד איזה קומפוננטה הכי מתאימה לאחסן בתוכה state. <strong>זה לעיתים קרובות החלק הכי מאתגר למתחילים ב</strong>React, לכן נעבור על השלבים הבאים על מנת להבין:</p>\n<p>לכל פיסת state ביישום:</p>\n<ul>\n<li>נזהה כל קומפוננטה שמרנדרת משהו מהstate.</li>\n<li>נמצא אם יש קומפוננטה אחרת למעלה בהיררכיה או קומפוננטה דומה שמתאימה לאחסן את הstate.</li>\n<li>אם לא נמצא קומפוננטה שמתאימה לאחסן את הstate, ניצור אחת חדשה שכל מטרתה היא לאחסן את הstate ונכניס אותה איפשהו בהיררכיה מעל קומפוננטה אחרת שמשתמשת בstate.</li>\n</ul>\n<p>נשתמש בשלבים אלה ביישום:</p>\n<ul>\n<li>ProductTable צריכה לסנן את רשימת המוצרים לפי הstate וSearchBar צריך להציג את טקסט החיפוש ותיבת הסימון.</li>\n<li>הקומפוננטה השנייה שעושה שימוש בstate היא FilterableProductTable.</li>\n<li>באופן עקרוני זה הגיוני שהטקסט המסונן והערך המסומן ‘יחיו’ בתוך FilterableProductTable.</li>\n</ul>\n<p>אז החלטנו שהstate ‘חי’ בתוך FilterableProductTable. ראשית, נוסיף אובייקט this.state = {filterText: ”, inStockOnly: false} לFilterableProductTable קונסטרקטור שלו על מנת לשקף את הstate  הראשוני של היישום.\nאחרי זה, נעביר את filterText  וinStockOnly לProductTable ו SearchBar כprop.\nלבסוף, נשתמש בprops האלה על מנת לסנן את השורות בProductTable ולהגדיר את הערכים של השדות בטופס בSearchBar.</p>\n<p>אפשר כבר להתחיל לראות איך היישום שלנו יתנהג: נגדיר את filterText ל”כדור” ונרענן את היישום. נראה שטבלת המידע מתעדכנת עם הערך הנכון.</p>\n<h2 id=\"step-5-add-inverse-data-flow\"><a href=\"#step-5-add-inverse-data-flow\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>שלב חמישי: הוספת זרימת מידע הפוכה </h2>\n<p data-height=\"600\" data-theme-id=\"0\" data-slug-hash=\"LzWZvb\" data-default-tab=\"js,result\" data-user=\"rohan10\" data-embed-version=\"2\" data-pen-title=\"Thinking In React: Step 5\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/gaearon/pen/LzWZvb\">Thinking In React: Step 5</a> on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<p>עד כה, בנינו יישום שמרנדר כפונקציה של props וstate  למטה בהיררכיה. עכשיו זה הזמן להוסיף אמצעי לזרימה הפוכה של מידע: קומפוננטות הטופס עמוק בהירככיה צריכות לעדכן את הstate בFilterableProductTable.</p>\n<p>React הופך את זרימת המידע למפורשת על מנת לעזור לך להבין איך היישום שלנו עובד, אבל זה דורש טיפה יותר שורות קוד מאשר binding דו כיווני של נתונים.</p>\n<p>אם ננסה לכתוב או לסמן את הקופסה בגרסה הקודמת של הדוגמא שלנו (שלב 4), נראה שReact מתעלם מהקלט שלנו. זה נעשה בכוונה, מכיוון שאנחנו הגדרנו את ערך הprop של הקלט להיות תמיד שווה לstate שמועבר מFilterableProductTable.</p>\n<p>נחשוב לרגע על מה אנחנו רוצים שיקרה. אנחנו רוצים להיות בטוחים שכשהמשתמש משנה את הטופס, אנחנו מעדכנים את הstate שישקף את קלט המשתמש. מכיוון שרצוי שקומפוננטות יעדכנו את הstate שלהן בלבד, FilterableProductTable יעביר callbacks לSearchBar שיופעלו כשהstate יתעדכן. אנחנו יכולים להשתמש בonChange event על הקלטים. הcallbacks שעוברים דרך FilterableProductTable יקראו למתודת  setState(), והיישום יתעדכן.</p>\n<p>אפילו שזה נשמע מסובך, זה בסך הכל מספר מצומצם של שורות קוד. והיתרון הוא שזה מציג באופן מפורש איך המידע מועבר ביישום.</p>\n<h2 id=\"and-thats-it\"><a href=\"#and-thats-it\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>וזהו! </h2>\n<p>הכוונה של המדריך הזה היא לתת לכם רעיון על איך לחשוב על בניית קומפוננטות ויישומים עם React. אמנם זה יכול לצרוך יותר כתיבה ממה שאתם רגילים, אבל זכרו שקוד נקרא יותר מאשר הוא נכתב, וזה נוח מאוד לקרוא את הקוד המפורש והמודולרי שכתבנו. כשתתחילו לבנות ספריות גדולות של קומפוננטות, אתם תעריכו את הפשטות והמודולריות, ועם שימוש חוזר בקוד שאתם רושמים, שורות הקוד שלכם יתחילו להתכווץ. 😊</p>"}